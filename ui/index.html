<script type="text/javascript" src="static/js/jquery.js"></script>
<script type="text/javascript" src="static/js/underscore.js"></script>
<script type="text/javascript" src="static/js/coffee-script.js"></script>
<script type="text/javascript" src="static/js/bean.js"></script>

<script type="text/javascript" src="static/js/jquery.event.drag-2.2.js"></script>
<script type="text/javascript" src="static/js/jquery-ui.js"></script>
<script src="static/js/slick.core.js"></script>
<script src="static/js/slick.grid.js"></script>
<script src="static/js/slick.dataview.js"></script>
<script src="static/js/slick.groupitemmetadataprovider.js"></script>
<script src="static/js/slick.rowselectionmodel.js"></script>
<link rel="stylesheet" href="static/css/jquery-ui.css" type="text/css"/>
<link rel="stylesheet" href="static/css/slick.grid.css" type="text/css"/>
<link rel="stylesheet" href="static/css/slick.columnpicker.css" type="text/css"/>
<link rel="stylesheet" href="static/css/slick-default-theme.css" type="text/css"/>

<script type="text/javascript" src="static/js/polymaps.js"></script>
<script type="text/javascript" src="/static/js/d3.v3.js"></script>

<script type="text/coffeescript" src="static/js/trusas.core.coffee"></script>
<script type="text/coffeescript" src="static/js/trusas.data.coffee"></script>

<script type="text/coffeescript" src="static/js/trusas.map.coffee"></script>

<script type="text/coffeescript" src="static/js/transit_analysis.coffee"></script>

<script type="text/javascript" src="static/js/buckets.js"></script>
<script type="text/coffeescript" src="static/js/dijkstra.coffee"></script>

<link rel="stylesheet" href="static/bootstrap/css/bootstrap.css" type="text/css"/>
<link rel="stylesheet/less" href="static/css/transit_analysis.less" type="text/css"/>

<script type="text/javascript" src="static/js/less-1.4.1.js"></script>

<style type="text/css">
/* SVG with less seems to work a bit randomly, so let's hack here */
.route_select_map .point_layer {
	opacity: 0.7;
}

.route_select_map .nodepoint {
	fill: black;
	stroke-width: 2;
}

.route_select_map .nodepoint:hover {
	stroke: black;
	stroke-width: 9;
}

.route_select_map .selected_nodepoint {
	fill: red;
	stroke: red;
	stroke-width: 6;
}

.route_select_map .selected_nodepoint:hover {
	fill: red;
	stroke: red;
	stroke-width: 9;
}

.route_select_map {
	position: relative;
}

.route_select_map .map_controls {
	position: absolute;
	bottom: 0;
	padding: 10px;
	width: 100%;
}

.route-select-widgets {
	margin-top: 30px;
	margin-left: 20px;
	margin-right: 20px;
}
</style>

<script type="text/coffeescript">
route_link_template = _.template """
<a href="<%= url %>" class="view-route-link">View</a>
"""

class Signal
	constructor: (@owner, @name) ->
	
	on: (cb) =>
		bean.on @owner, @name, cb
	off: (cb) =>
		bean.off @owner, @name, cb
	trigger: (args...) =>
		bean.fire @owner, @name, args

class SignalingValue
	constructor: (@_value) ->
		@changed = new Signal @, "changed"
	
	set: (@_value) =>
		@changed.trigger @_value
	
	get: => @_value
	
class Controller
	@Create: ->
		routes = $.getJSON '/resources/transit_routes.json'
		shapes = $.getJSON '/resources/coordinate_shapes.json'
		graph = $.getJSON '/resources/route_graph_edges.json'
		promise = $.Deferred()
		$.when(routes, shapes, graph).done (args...) ->
			args = (a[0] for a in args)
			self = new Controller(args...)
			promise.resolve self

		return promise

	constructor: (@routes, @shapes, @graph) ->
		@selected_nodes = new SignalingValue([])
		@selected_route = new SignalingValue()
		@reachable_nodes = new SignalingValue(@graph.nodes)
	
	selection_url: =>
		return null if not @selected_route.get()
		return "route.html?route_nodes=" + @selected_nodes.get().join()


_setup_map = (ctrl) ->
	# Far from optimal
	graph = ctrl.graph
	
	coords = []
	ids = []

	for k, v of graph.nodes
		coords.push(v)
		ids.push(k)
	
	
	minc = [
		_.min(coords, (x) -> x[0])[0]
		_.min(coords, (x) -> x[1])[1]
		]
	
	maxc = [
		_.max(coords, (x) -> x[0])[0]
		_.max(coords, (x) -> x[1])[1]
		]
	
	selected_nodes = ctrl.selected_nodes
	
	Trusas.Map.Create($("#route_map")[0]).done (route_map) ->
		extent = [minc, maxc]
		route_map.set_extent(extent)
		styler = (style) -> style

		onload = (opts) ->
			for feat in opts.features
				hook_events(feat)
		
		points = []
		for i in [0...coords.length]
			c = coords[i]
			points.push
				lat: c[0]
				lon: c[1]
				id: ids[i]
		
		point_layer = route_map.add_points(points)
		
		d3.select(point_layer.element).selectAll('circle')
		.attr('class', 'nodepoint')
		.attr('r', 2)
		
		
		$(point_layer.element).find('.nodepoint').click (args...) ->
			$el = $ @
			sel = selected_nodes.get()
			id = $el.attr('id')
			idx = sel.indexOf(id)
			if idx >= 0
				sel.splice(idx, 1)
			else
				sel.push id
				
			selected_nodes.set(sel)

		# A weird mix of d3 and jquery deepens

		selected_nodes.changed.on (nodes) ->
			np = $ ".nodepoint"
			np.attr("class", "nodepoint")
			np.empty()
			for n in nodes
				el = $("##{n}")
				el.attr("class", "nodepoint selected_nodepoint")

		ctrl.selected_route.changed.on (route) ->
			route_map.remove_layer "selected_route"
			return if not route
			coords = (graph.nodes[k] for k in route)

			route_map.add_route coords, "selected_route",
				(style) -> style.attr("class", "selected_route_line")

		ctrl.reachable_nodes.changed.on (whitelist) ->
			$(".nodepoint").attr 'display', 'none'
			for node of whitelist
				$("##{node}").attr 'display', 'inline'
			for node in ctrl.selected_nodes.get()
				$("##{node}").attr 'display', 'inline'
		
		controls = $(route_map.el).append("""
		<div class="map_controls">
		<button class="clear_selection btn btn-danger">Clear selection</button>
		<a class="view_route btn btn-success pull-right">View route</a>
		</div>
		""")
		clear_btn = controls.find('.clear_selection')
		clear_btn.addClass('disabled')
		selected_nodes.changed.on (sel) ->
			if sel.length > 0
				clear_btn.removeClass 'disabled'
			else
				clear_btn.addClass 'disabled'

		clear_btn.click ->
			selected_nodes.set([])
		
		view_btn = controls.find('.view_route')
		view_btn.addClass('disabled')
		ctrl.selected_route.changed.on (sel) ->
			if sel
				view_btn.removeClass 'disabled'
				view_btn.attr "href", ctrl.selection_url()
			else
				view_btn.addClass 'disabled'
				view_btn.removeAttr "href"


_setup_table = (ctrl) ->
	data = ctrl.routes
	columns = ({id: n, field: n, name: n} \
		for n of data[0] when n not in ['id'])
	
	depcol = $.grep(columns, (e) -> e.id == 'departures')[0]
	depcol['groupTotalsFormatter'] = (total, coldef) ->
		return total.sum.departures
	
	routecol = $.grep(columns, (e) -> e.id == 'route_name')[0]
	routecol['formatter'] = (args...) ->
		row = args[4]
		urlargs = _.pick row, 'route_variant', 'direction', 'shape'
		url = "route.html?"+$.param urlargs
		return route_link_template url: url
		

	[columns[1], columns[0]] = [columns[0], columns[1]]
		
	groupItemMetadataProvider = new Slick.Data.GroupItemMetadataProvider()
	dataView = new Slick.Data.DataView
		groupItemMetadataProvider: groupItemMetadataProvider
		inlineFilters: true

	dataView.setGrouping(
		getter: 'route_name'
		formatter: (g) -> g.value
		#aggregators: [
		#	new Slick.Data.Aggregators.Sum("departures")
		#	]
		aggregateCollapsed: true
		collapsed: true)
	dataView.setItems(data)
	grid = new Slick.Grid "#departure_grid", dataView, columns,
		forceFitColumns: true
		multiSelect: false

	grid.registerPlugin groupItemMetadataProvider
	grid.setSelectionModel new Slick.RowSelectionModel()

	dataView.onRowCountChanged.subscribe (e, args) ->
		grid.updateRowCount()
		grid.render()
	
	dataView.onRowsChanged.subscribe (e, args) ->
		grid.invalidateRows(args.rows)
		grid.render()

_setup_router = (ctrl) ->
	edges = {}
	for [from, to, data] in ctrl.graph.edges
		edges[from] ?= {}
		edges[from][to] = data
	
	ctrl.selected_nodes.changed.on (nodes) ->
		if nodes.length == 0
			ctrl.selected_route.set null
			ctrl.reachable_nodes.set ctrl.graph.nodes
			return
		
		reachable_shapes = {}

		# Find all shapes that have a route through
		# these nodes
		for shape in ctrl.shapes
			node_ids = shape.node_ids
			prev = node_ids.indexOf(nodes[0])
			continue if prev < 0
			idx = [prev]
			
			dobreak = false
			for n in nodes[1...]
				next = node_ids[prev+1...].indexOf(n)
				if next < 0
					dobreak = true
					break
				prev = next + prev + 1
				idx.push prev
			continue if dobreak
				
			reachable_shapes[shape.shape] =
				nodes: node_ids[idx[0]..idx[idx.length-1]]
				reachable_nodes: node_ids[idx[0]+1...]
				dist: shape.distances[idx[1]] - shape.distances[idx[0]]
		
		if nodes.length < 2
			reachable_nodes = {}
			for shape, data of reachable_shapes
				reachable_nodes[n] = true for n in data.reachable_nodes
			ctrl.selected_route.set null
			ctrl.reachable_nodes.set reachable_nodes
			return

		
		# Find shortest of such routes
		mindist = Number.MAX_VALUE
		minshape = undefined
		for shape, data of reachable_shapes
			if data.dist < mindist
				mindist = data.dist
				minshape = data

		# And filter only ones that are equal to this
		# A bit hacky comparison but should work
		minseqstr = "#{minshape.nodes}"
		for shape, data of reachable_shapes
			if "#{data.nodes}" != minseqstr
				delete reachable_shapes[shape]

		reachable_nodes = {}
		for shape, data of reachable_shapes
			reachable_nodes[n] = true for n in data.reachable_nodes

		ctrl.selected_route.set minshape.nodes
		ctrl.reachable_nodes.set reachable_nodes
		
$ ->
	Controller.Create().done (ctrl) ->
		window.debugctrl = ctrl
		_setup_map ctrl
		_setup_table ctrl
		_setup_router ctrl

</script>
<div class="widget-container route-select-widgets row">
	<div class="col-md-6" style="height: 425px">
		<axislabel class="toplabel acttopbin">Route map</axislabel>
		<div id="route_map" class="route_select_map"></div>
	</div>
	<div class="col-md-6" style="height: 425px;">
		<axislabel class="toplabel acttopbin">Route table</axislabel>
		<div id="departure_grid"></div>
	</div>
</div>
