<!DOCTYPE html>

<script type="text/javascript" src="static/js/jquery.js"></script>
<script type="text/javascript" src="static/js/bean.js"></script>
<script type="text/javascript" src="static/js/jquery-deparam.js"></script>
<script type="text/javascript" src="static/js/coffee-script.js"></script>

<script type="text/coffeescript" src="static/js/trusas.core.coffee"></script>
<script type="text/coffeescript" src="static/js/trusas.data.coffee"></script>
<script type="text/coffeescript" src="static/js/transit_analysis.coffee"></script>

<!--<script type="text/javascript" src="static/js/Cesium/Cesium.js"></script>
<link rel="stylesheet" type="text/css" src="static/js/Cesium/Widgets/CesiumWidget/CesiumWidget.css" /> -->
<script type="text/javascript" src="static/js/polymaps.js"></script>

<script type="text/coffeescript" src="static/js/trusas.map.coffee"></script>

<script type="text/javascript" src="/static/js/jquery.flot.js"></script>
<script type="text/javascript" src="/static/js/jquery.flot.crosshair.js"></script>
<script type="text/javascript" src="/static/js/jquery.flot.navigate.js"></script>
<script type="text/javascript" src="/static/js/jquery.flot.fillbetween.js"></script>

<script type="text/javascript" src="/static/js/d3.v3.js"></script>

<script type="text/javascript" src="/static/js/science.v1.js"></script>

<!--<script type="text/javascript" src="static/js/envision.min.js"></script>
<link rel="stylesheet" href="static/css/envision.min.css" type="text/css"/> -->

<script type="text/javascript" src="static/js/underscore.js"></script>

<link rel="stylesheet" href="static/bootstrap/css/bootstrap.css" type="text/css"/>
<link rel="stylesheet/less" href="static/css/transit_analysis.less" type="text/css"/>

<script type="text/javascript" src="static/js/less-1.4.1.js"></script>

<script type="text/coffeescript">

double_freedman_fiaconis_binw = (values) ->
	science.stats.iqr(values)/Math.pow(values.length, 1/3)
	

histogram = (values, binw=double_freedman_fiaconis_binw) ->
		min = Math.min values...
		max = Math.max values...
		values = _.sortBy values, (x) -> x
		step = binw values
		
		hist = [[min+step, 0]]
		currow = hist[0]
		for v in values
			while v > currow[0]
				currow = [currow[0]+step, 0]
				hist.push currow
			currow[1] += 1
		return [step, hist]

nonnans = (xs) -> (x for x in xs if x == x)

find_next_valid = (a, idx, thres=10) ->
	for i in [idx...idx+thres]
		if i >= a.length
			break
		if a[i] == a[i]
			return a[i]
	return NaN
	
find_prev_valid = (a, idx, thres=10) ->
	start = Math.max(idx-thres, 0)
	for i in [start..idx]
		if a[i] == a[i]
			return a[i]
	return NaN

find_close_valid = (a, idx, dir=1, thres=100) ->
	funcs = [find_next_valid, find_prev_valid]
	v = funcs[0] a, idx, thres
	return v if v == v
	v = funcs[1] a, idx, thres

clip_linestring = (bbox, coords, dists) ->
	contains = (c) ->
		return false if c[0] < bbox[0][0]
		return false if c[0] > bbox[1][0]
		return false if c[1] < bbox[0][1]
		return false if c[1] > bbox[1][1]
		return true
	
	contained = []
	i = 0
	n = coords.length
	while i < n
		if not contains(coords[i])
			++i; continue
		span = []
		contained.push span
		while i < n
			break if not contains(coords[i])
			span.push i
			++i
	
	if contained.length == 0
		return [NaN, NaN]
	
	# TODO: Interpolate!
	maxspan = []
	maxlen = -1
	for span in contained
		s = span[0]
		e = span[span.length-1]
		len = dists[e] - dists[s]
		if len > maxlen
			maxlen = len
			maxspan = [dists[s], dists[e]]
	
	return maxspan
	


class DataController
	constructor: (@con) ->
		
		@cursor = new TrusasCursor()

		query = $.deparam(window.location.search[1..])
		traces_query = "resources/departure_traces.json"+window.location.search

		traces_promise = @con()
			.distance_grid()
			.time_spent_stats()
			.speed_stats()
			.departures()
			.stops()
			.stop_duration_stats()
			.inter_stop_duration_stats()
			.coordinate_shape()()
		
		traces_promise.done (data) =>
			@_setup_cursor data.coordinate_shape
		traces_promise.done @_setup_data

		@span_durations = new TransAnal.DynamicValue (start, end) =>
			@con.span_durations start: start, end: end
		
		@ready = $.Deferred()
		
		promises = $.when traces_promise
		promises.done => @ready.resolve @
	
	_setup_cursor: (data) =>
		@route = data
		[lats, lons] = _.zip(data.coordinates...)
		@cursor.accommodateAxisRange _.min(data.distances), _.max(data.distances)
		@pos_to_coords = Trusas.coord_interp data.distances, lats, lons
		@cursorpath = Trusas.rangepath data.distances, lats, lons
		
		$(@cursor).on "activeRangeChange", dcall ((e, rng) =>
			@span_durations.refresh rng[0], rng[1]), 1000
	
	_setup_data: (data) =>
		for key of data
			@[key] = data[key]

	distanceGridIndex: (dist) =>
		return Math.round dist/@distance_bin_width

format_seconds = (seconds) ->
	return seconds
	# TODO: See if something sensical can
	# be made of this
	hours = Math.floor(seconds/(60*60))
	seconds -= hours*60*60
	minutes = Math.floor(seconds/60)
	seconds -= minutes*60
	seconds = Math.round(seconds)
	if hours > 0
		str = "#{hours}h"
		if minutes > 0 and hours < 10
			str += " #{minutes}m"
		return str
	if minutes > 0
		str = "#{minutes}m"
		if seconds == 0
			return str
		if seconds > 0 and minutes < 10
			str += " #{seconds}s"
		return str
	return "#{seconds}s"

route_header_template = _.template """
	<a href="index.html">&lt;&lt; Back</a> |
		Route <%= route_variant %>, direction <%= direction %>, shape <%= shape %>
	"""

custom_header_template = _.template """
	<a href="index.html">&lt;&lt; Back</a> |
		Custom route
	"""



_setup = (ctrl) ->
	$(ctrl.cursor).on "activeRangeChange", (e, rng) ->
		hash = "#{Math.round(rng[0])}:#{Math.round(rng[1])}"
		window.location.replace(('' + window.location).split('#')[0] + '#' + hash)

	hash = window.location.hash[1..]
	if hash != ''
		rngÂ = (parseFloat p for p in hash.split ':')
		ctrl.cursor.setActiveRange rng
	
	_setup_seq_plot ctrl
	_setup_map ctrl
	_setup_plots ctrl

_setup_map = (ctrl) ->
	Trusas.Map.Create($("#route-map")[0]).done (route_map) ->
		stats = ctrl.speed_stats
		end_distance = ctrl.distance_grid[ctrl.distance_grid.length-1]
		norm_distance = []
		for v in ctrl.distance_grid
			norm_distance.push v/end_distance

		#stat = (stats.lowq[i] - stats.highq[i] for i in [0...stats.highq.length])
		stat = stats.lowq
		#stat = (Math.log v + 1.0 for v in stat)
		validstat = (v for v in stat when v == v)
		min = Math.min validstat...
		max = Math.max validstat...
		rng = max - min
		norm_stat = []
		for v in stat
			norm_stat.push (v - min)/rng

		medinterp = Trusas.interp1d norm_distance, norm_stat
		route_map.add_colored_route ctrl.route.coordinates, medinterp,
			10.0/end_distance



		for stop in ctrl.stops
			route_map.add_marker [stop.latitude, stop.longitude]

		extent_setup = (rng) ->
			subpath = ctrl.cursorpath rng...
			extent = Trusas.coords_extent subpath
			route_map.set_extent extent
			route_map.set_active_path subpath
		
		ignore_next_range = false
		$(ctrl.cursor).on "activeRangeChange", (e, rng) ->
			# TODO: Don't calculate subpath twice
			subpath = ctrl.cursorpath rng...
			route_map.set_active_path subpath
			if ignore_next_range
				ignore_next_range = false
				return
				
			extent_setup rng

		# TODO: For some reason this fails if done too early,
		# so a hack.
		setTimeout (-> extent_setup ctrl.cursor.getActiveRange()), 100
		
		$(ctrl.cursor).on "hoverPositionChange", (e, pos) ->
			coords = ctrl.pos_to_coords pos
			if not coords[0]?
				coords = undefined
			route_map.set_hover coords
		
		route_map.onmove (ext) ->
			rng = Trusas.longest_clipped_linestring ext,
				ctrl.route.coordinates,
				ctrl.route.distances
			if rng[0] != rng[0]
				rng = ctrl.cursor.getAxisRange()
			# Ignore the next range change to avoid
			# free scrolling of the map
			ignore_next_range = true
			ctrl.cursor.setActiveRange rng

_setup_plots = (ctrl) ->
	stats = ctrl.speed_stats

	items = []

	color = "black"
	items.push
		data: _.zip(ctrl.distance_grid, stats.median)
		color: color
	
	items.push
		data: _.zip(ctrl.distance_grid, stats.lowp)
		id: 'lowp'
		shadowSize: 0
		lines: show: true, fill: false, lineWidth: 0
		color: color
	
	items.push
		data: _.zip(ctrl.distance_grid, stats.highp)
		shadowSize: 0
		fillBetween: 'lowp'
		lineWidth: 0
		color: color
		lines: show: true, fill: 0.3, lineWidth: 0
	
	items.push
		data: _.zip(ctrl.distance_grid, stats.lowq)
		id: 'lowq'
		shadowSize: 0
		color: color
		lines: show: true, fill: false, lineWidth: 0
	
	items.push
		data: _.zip(ctrl.distance_grid, stats.highq)
		shadowSize: 0
		fillBetween: 'lowq'
		lineWidth: 0
		color: color
		lines: show: true, fill: 0.3, lineWidth: 0
	
	timeticks = [0, 1, 5, 10, 20, 30, 60, 120, 300, 600]
	el = $("#route-speed")
	plot = $.plot el, items,
		zoom: interactive: true
		pan: interactive: true
		yaxis:
			panRange: false
			zoomRange: false
			#min: 0.0
			#ticks: timeticks
			#tickFormatter: format_seconds
			#max: 120
			#transform: (x) -> Math.log(x+1)
		xaxis:
			panRange: ctrl.cursor.getAxisRange()
			zoomRange: ctrl.cursor.getAxisRange()
			min: ctrl.cursor.getActiveRange()[0]
			max: ctrl.cursor.getActiveRange()[1]
		grid: hoverable: true
		crosshair: mode: 'x'

	update_cursor = ->
		axes = plot.getAxes()
		start = axes.xaxis.min
		end = axes.xaxis.max
		ctrl.cursor.setActiveRange([start, end])
	
	$(ctrl.cursor).on "activeRangeChange", ->
		rng = ctrl.cursor.getActiveRange()
		opts = plot.getAxes().xaxis.options
		opts.min = rng[0]
		opts.max = rng[1]
		plot.setupGrid()
		plot.draw()
	
	$(el).bind "plotzoom", update_cursor
	$(el).bind "plotpan", update_cursor

	$(el).bind "plothover", (event, pos, item) ->
		ctrl.cursor.setHoverPosition pos.x
	
	plot_durations = (durarr) ->
		durations = []
		for v in durarr
			continue if v != v
			durations.push v
		valid = deoutlier(durations)[0]
		[binsize, binned] = histogram(valid)
		n = valid.length
		for i in [0...binned.length]
			inbin = binned[i][1]
			binned[i][1] = inbin/n*100

		$.plot $("#route-duration"), [{
			data: binned,
			color: "black",
			}],
			bars:
				show: true
				barWidth: binsize
				lineWidth: 0
				fill: 0.5
			xaxis:
				tickFormatter: format_seconds
	ctrl.span_durations.$update.on plot_durations

	plot_dur_tod = (durarr) ->
		durations = []
		durations = []
		for v in durarr
			continue if v != v
			durations.push v
		durarr = deoutlier(durations)[0]
		durations = []
		for i in [0...durarr.length]
			date = new Date ctrl.departures[i].departure_time
			minutes = date.getHours()*60 + date.getMinutes()
			durations.push [minutes, durarr[i]]

		$.plot $("#duration-by-tod"), [{data: durations, color: "rgb(0,0,0,0.5)"}],
			series:
				shadowSize: 0
				points:
					radius: 3
					show: true
					fill: 0.5
					fillColor: "black"
					lineWidth: 0
			xaxis:
				tickFormatter: (x) ->
					hours = Math.floor(x/60)
					minutes = String(x - hours*60)
					if minutes.length < 2
						minutes = "0" + minutes
					"#{hours}:#{minutes}"
			yaxis:
				tickFormatter: format_seconds
	ctrl.span_durations.$update.on plot_dur_tod

_setup_seq_plot = (ctrl) ->
	plot = new TransAnal.StopSeqPlot "#route-seq", ctrl
	$(".acttopbin").click ->
		plot.pin_top_toggle()
	$(".actbottombin").click ->
		plot.pin_bottom_toggle()
		

		
$ ->
	query = $.deparam(window.location.search[1..])
	if "route_nodes" of query
		header = custom_header_template query
	else
		header = route_header_template query
	
	$("#session-info").html(header)
	
	promise = TransAnal.Stats.Connect query
	promise.done (con) ->
		ctrl = new DataController(con)
		ctrl.ready.done _setup

</script>
<div id="session-info"></div>
<div class="widget-container" class="row">
	<div class="col-6" style="height: 425px">
		<div id="route-map"></div>
	</div>
	<div class="col-6" style="height: 200px;">
		<div id="route-speed"></div>
		<axislabel class="xlabel">Distance (m)</axislabel>
		<axislabel class="ylabel">Speed (km/h)</axislabel>
	</div>
	<div class="col-6" style="height: 200px;">
		<div id="route-duration"></div>
		<axislabel class="xlabel">Time spent</axislabel>
		<axislabel class="ylabel">Share of drives (%)</axislabel>

	</div>
	<div class="col-6" style="height: 200px;">
		<axislabel class="toplabel acttopbin">Stops (stop %)</axislabel>
		<div id="route-seq"></div>
		<axislabel class="xlabel actbottombin">Between stops (time spent)</axislabel>
	</div>

	<div class="col-6" style="height: 200px;">
		<div id="duration-by-tod"></div>
		<axislabel class="xlabel">Time of day</axislabel>
		<axislabel class="ylabel">Time spent</axislabel>
	</div>
</div>
