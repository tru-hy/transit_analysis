<script type="text/javascript" src="static/js/jquery.js"></script>
<script type="text/javascript" src="static/js/jquery-deparam.js"></script>
<script type="text/javascript" src="static/js/coffee-script.js"></script>

<script type="text/coffeescript" src="static/js/trusas.core.coffee"></script>

<script type="text/javascript" src="static/js/Cesium/Cesium.js"></script>
<link rel="stylesheet" href="static/css/transit_analysis.css" type="text/css" src="static/js/Cesium/Widgets/CesiumWidget/CesiumWidget.css" />

<script type="text/coffeescript" src="static/js/trusas.map.coffee"></script>

<script type="text/javascript" src="/static/js/jquery.flot.js"></script>
<script type="text/javascript" src="/static/js/jquery.flot.crosshair.js"></script>
<script type="text/javascript" src="/static/js/jquery.flot.navigate.js"></script>

<script type="text/javascript" src="/static/js/science.v1.js"></script>

<!--<script type="text/javascript" src="static/js/envision.min.js"></script>
<link rel="stylesheet" href="static/css/envision.min.css" type="text/css"/> -->

<script type="text/javascript" src="static/js/underscore.js"></script>

<link rel="stylesheet" href="static/css/transit_analysis.css" type="text/css"/>

<script type="text/coffeescript">

histogram = (values, bins) ->
		min = Math.min values...
		max = Math.max values...
		step = (max - min)/bins
		values = _.sortBy values, (x) -> x
		
		hist = [[min+step, 0]]
		currow = hist[0]
		for v in values
			while v > currow[0]
				currow = [currow[0]+step, 0]
				hist.push currow
			currow[1] += 1
		return [step, hist]

nonnans = (xs) -> (x for x in xs if x == x)

find_next_valid = (a, idx, thres=10) ->
	for i in [idx...idx+thres]
		if i >= a.length
			break
		if a[i] == a[i]
			return a[i]
	return NaN
	
find_prev_valid = (a, idx, thres=10) ->
	start = Math.max(idx-thres, 0)
	for i in [start..idx]
		if a[i] == a[i]
			return a[i]
	return NaN

find_close_valid = (a, idx, dir=1, thres=100) ->
	funcs = [find_next_valid, find_prev_valid]
	v = funcs[0] a, idx, thres
	return v if v == v
	v = funcs[1] a, idx, thres

class DataController
	constructor: ->
		@cursor = new TrusasCursor()

		query = $.deparam(window.location.search[1..])
		@shape_promise = $.getJSON \
			"resources/coordinate_shape.json?"+$.param(_.pick(query, 'shape'))

		traces_query = "resources/departure_traces.json"+window.location.search
		@traces_promise = $.getJSON traces_query
			
		@shape_promise.done @_setup_cursor
		@traces_promise.done @_setup_data
	
	_setup_cursor: (data) =>
		[lats, lons] = _.zip(data.coordinates...)
		@cursor.accommodateAxisRange _.min(data.distances), _.max(data.distances)
		@pos_to_coords = Trusas.coord_interp data.distances, lats, lons
		@cursorpath = Trusas.rangepath data.distances, lats, lons
	
	_setup_data: (data) =>
		@data = data

		dist_grid_len = data[0].time_at_distance_grid.length

		dist_bin_width = data[0].distance_bin_width
		@distance_bin_width = data[0].distance_bin_width
		@distance_grid = (i*dist_bin_width for i in [0..dist_grid_len])

		diff = (x) ->
			(x[i] - x[i-1] for i in [1..x.length-1])

		nulltonan = (x) ->
			for i in [0..x.length]
				if not x[i]?
					x[i] = NaN
			return x

		for d in data
			d.time_at_distance = nulltonan d.time_at_distance_grid
			d.time_spent = diff d.time_at_distance
		
		@time_spent_stats =
			mean: []
			std: []
			lowp: []
			median: []
			highp: []
			ipr: []

		for i in [0..@distance_grid.length]
			valid = []
			sum = 0.0
			for d in data
				v = d.time_spent[i]
				continue if v != v
				sum += v
				valid.push v
			mean = sum/valid.length
			@time_spent_stats.mean.push sum/valid.length
			[l, m, h] = science.stats.quantiles valid, [.05, .5, .95]
			@time_spent_stats.lowp.push l
			@time_spent_stats.median.push m
			@time_spent_stats.highp.push h
			@time_spent_stats.ipr.push h - l

			sqsum = 0.0
			for v in valid
				delta = v-mean
				sqsum += delta*delta
			@time_spent_stats.std.push Math.sqrt(sqsum/(valid.length-1))
		
	distanceGridIndex: (dist) =>
		return Math.round dist/@distance_bin_width

format_seconds = (seconds) ->
	hours = Math.floor(seconds/(60*60))
	seconds -= hours*60*60
	minutes = Math.floor(seconds/60)
	seconds -= minutes*60
	seconds = Math.round(seconds)
	if hours > 0
		str = "#{hours}h"
		if minutes > 0 and hours < 10
			str += " #{minutes}m"
		return str
	if minutes > 0
		str = "#{minutes}m"
		if seconds == 0
			return str
		if seconds > 0 and minutes < 10
			str += " #{seconds}s"
		return str
	return "#{seconds}s"
	

$ ->
	ctrl = new DataController()

	ctrl.shape_promise.done (data) ->
		route_map = new Trusas.Map $("#route-map")[0]
		route_map.add_route "default", data.coordinates

		
		extent_setup = (rng) ->
			subpath = ctrl.cursorpath rng...
			extent = Trusas.coords_extent subpath
			route_map.set_extent extent
		
		$(ctrl.cursor).on "activeRangeChange", (e, rng) -> extent_setup rng
		# TODO: For some reason this fails if done too early,
		# so a hack.
		setTimeout (-> extent_setup ctrl.cursor.getActiveRange()), 100

		$(ctrl.cursor).on "hoverPositionChange", (e, pos) ->
			coords = ctrl.pos_to_coords pos
			if not coords[0]?
				coords = undefined
			route_map.set_hover coords


	###
	traces_promise.done (data) ->
		series = []
		for d in data
			s =
				data: [d.route_distance, d.route_speed]
				color: "rgba(0,0,0,0.1)"

			series.push s
		
		opts =
			container: $("#route-speed")[0],
			data:
				detail: series,
				summary: series
			defaults:
				detail: config:
					yaxis: showLabels: true
				summary: config:
					xaxis: showLabels: true


		series = new envision.templates.TimeSeries opts
		return

		vis = new envision.Visualization()
		graph = new envision.Component
			name: "speeds"
			config:
				'lite-lines':
					lineWidth: 1
					show: true
				selection:
					mode: "x"
				xaxis: showLabels: true
			data: series
			height: "100%"
		
		vis
			.add(graph)
			.render $("#route-speed")[0]

		interact = new envision.Interaction()
		interact
			.group([graph])
			.add(envision.actions.zoom, {})
		

	###
	ctrl.traces_promise.done ->
		data = ctrl.data
		drives = []
		
		
		dist_grid_len = data[0].time_at_distance_grid.length

		dist_bin_width = data[0].distance_bin_width
		dist_grid = (i*dist_bin_width for i in [0..dist_grid_len])
		"""
		for d in data
			drive = {}
			#drive.data = _.zip(d.route_distance, d.route_speed)
			drive.data = _.zip(ctrl.distance_grid, d.time_spent)
			drive.color = "rgba(0,0,0,0.1)"
			drive.shadowSize = 0
			drives.push drive
		"""
		
		drives.push
			data: _.zip(ctrl.distance_grid, ctrl.time_spent_stats.median)
			color: "blue"
			shadowSize: 0
		
		normstd = (ctrl.time_spent_stats.ipr[i]/ctrl.time_spent_stats.median[i]\
			for i in [0..dist_grid_len])
		drives.push
			data: _.zip(ctrl.distance_grid, ctrl.time_spent_stats.lowp)
			color: "red"
			shadowSize: 0
		
		drives.push
			data: _.zip(ctrl.distance_grid, ctrl.time_spent_stats.highp)
			color: "red"
			shadowSize: 0

		timeticks = [0, 1, 5, 10, 20, 30, 60, 120, 300, 600]
		el = $("#route-speed")
		plot = $.plot el, drives,
			zoom: interactive: true
			pan: interactive: true
			yaxis:
				panRange: false
				zoomRange: false
				min: 0.5
				ticks: timeticks
				tickFormatter: format_seconds
				transform: (x) -> Math.log(x+1)
			xaxis:
				panRange: ctrl.cursor.getAxisRange()
				zoomRange: ctrl.cursor.getAxisRange()
			grid: hoverable: true
			crosshair: mode: 'x'

		update_cursor = ->
			axes = plot.getAxes()
			start = axes.xaxis.min
			end = axes.xaxis.max
			ctrl.cursor.setActiveRange([start, end])
		
		$(el).bind "plotzoom", update_cursor
		$(el).bind "plotpan", update_cursor

		$(el).bind "plothover", (event, pos, item) ->
			ctrl.cursor.setHoverPosition pos.x
	
	ctrl.traces_promise.done ->
		plot_durations = ->
			rng = ctrl.cursor.getActiveRange()
			[start, end] = (ctrl.distanceGridIndex x for x in rng)
			durations = []
			for d in ctrl.data
				t_at_d = d.time_at_distance_grid
				duration = find_close_valid(t_at_d, end, 1) - find_close_valid(t_at_d, start, -1)
				continue if duration != duration
				continue if duration == 0
				durations.push duration
			
			[binsize, binned] = histogram(durations, 15)
			$.plot $("#route-duration"), [{data: binned}],
				bars:
					show: true
					barWidth: binsize
				xaxis:
					tickFormatter: format_seconds

		$(ctrl.cursor).on "activeRangeChange", plot_durations
		plot_durations()
	
	ctrl.traces_promise.done ->
		plot_dur_tod = ->
			rng = ctrl.cursor.getActiveRange()
			[start, end] = (ctrl.distanceGridIndex x for x in rng)
			durations = []
			for d in ctrl.data
				t_at_d = d.time_at_distance_grid
				duration = find_close_valid(t_at_d, end, 1) - find_close_valid(t_at_d, start, -1)
				continue if duration != duration
				continue if duration == 0
				date = new Date d.departure_time
				minutes = date.getHours()*60 + date.getMinutes()
				durations.push [minutes, duration]

			$.plot $("#duration-by-tod"), [{data: durations}],
				series:
					points:
						radius: 3
						show: true
				xaxis:
					tickFormatter: (x) ->
						hours = Math.floor(x/60)
						minutes = String(x - hours*60)
						if minutes.length < 2
							minutes = "0" + minutes
						"#{hours}:#{minutes}"
				yaxis:
					tickFormatter: format_seconds

		$(ctrl.cursor).on "activeRangeChange", plot_dur_tod
		plot_dur_tod()
			
</script>

<div id="route-map" style="width: 600px; height: 600px; float: left;"></div>
<div id="route-speed" style="width: 49%; height: 200px; float: left;"></div>
<div id="route-duration" style="width: 49%; height: 200px; float: left;"></div>
<div id="duration-by-tod" style="width: 49%; height: 200px; float: left;"></div>
